

有 n 件物品和一个最多能背重量为 w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大

### 模板

#### 二维数组



- dp\[i][j]定义：从下标为[0 - i]的物品里任意取，放进容量为 j 的背包，价值总和最大为多少
- 递推公式
  - 不放物品 i ：dp\[i][j] = dp\[i - 1][j]
    - 当物品 i 的容量大于 j 时，物品 i 无法放进背包中，故背包价值和之前相同
  - 放物品 i ： dp\[i][j] = Math.max(dp\[i - 1][j], dp\[i - 1][j - weight[i]] + value[i])
    - dp\[i - 1][j - weight[i]] + value[i]为背包容量 j - weight[i]时放物品 i 的最大价值
- 初始化：
  - dp\[0][j]，当存放下标为 0 时的物品，各个容量背包所能存放的最大价值
    - 当 j < weight[0]时，dp\[0][j] = 0
    - 当 j > weight[0]时，dp\[0][j] = value[0]



```java
public static void main(String[] args) {
        int[] weight = {1, 3, 4};
        int[] value = {15, 20, 30};
        int bagsize = 4;
        backpack1(weight, value, bagsize);
    }

    public static void backpack1(int[] weight, int[] value, int bagsize) {
        int n = weight.length;
        int[][] dp = new int[n][bagsize + 1];

        for (int j = weight[0]; j <= bagsize; j++) {//初始化
            dp[0][j] = value[0];
        }
        for (int i = 1; i < n; i++) {//遍历物品
            for (int j = 0; j <= bagsize; j++) {//遍历重量
                if (j < weight[i]) dp[i][j] = dp[i - 1][j];
                else dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
            }
        }
        System.out.println(dp[n - 1][bagsize]);
    }
```

#### 一维数组



- dp[j] ：表示背包容量为 j 时，能获得的最大价值
- 递推：Math.max(dp[j], dp[j - weight[i]] + value[i])
- 初始化：容量为0，价值为0，故初始都为0
- j >= weight[i] 保证每个物品只用一次



```java
    public static void main(String[] args) {
        int[] weight = {1, 3, 4};
        int[] value = {15, 20, 30};
        int bagsize = 4;
        backpack2(weight,value,bagsize);
    }

    public static void backpack2(int[] weight, int[] value, int bigsize) {
        int n = weight.length;
        int[] dp = new int[bigsize + 1];

        for (int i = 0; i < n; i++) {//遍历物品
            for (int j = bigsize; j >= weight[i]; j--) {
                dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
            }
        }
        System.out.println(dp[bigsize]);
    }
```





### 分割等和子集

[416. 分割等和子集 - 力扣（Leetcode）](https://leetcode.cn/problems/partition-equal-subset-sum/description/)

![](https://yingziimage.oss-cn-beijing.aliyuncs.com/img/202302212250210.png)

- 0 - 1 背包中，dp[j] 可表示为：容量为 j 的背包，所背物品价值最大可以为 dp[j]
- 定义此题dp[j]，物品 i 的重量是 nums[i]，其价值也是 nums[i]
- 递推公式：dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i])
- 总和 sum 为 奇数 不能平分，故返回 false
- 背包容量为 target = sum / 2，当 dp[target] == target 时，背包刚好装满
  - 数组 [1，5，3，5]。举例 dp[7] = 6，因为只能放入 1 和 5，此时返回 false
  - 数组 [1，5，3，7]。举例 dp[8] = 8，因为只能放入 1 和 7（或 3 和 5），此时返回 true



```java
class Solution {
    public boolean canPartition(int[] nums) {
        int n = nums.length;

        int sum = 0;
        for (int num : nums){
            sum += num;
        }
        // 若总和为奇数，不能平分
        if (sum % 2 != 0) return false;

        int target = sum / 2;
        // dp[i] : 下标为i时，能组合最大的值
        int[] dp = new int[target + 1];
        for (int i = 0;i < n;i++){
            for (int j = target;j >= nums[i];j--){
                dp[j] = Math.max(dp[j],dp[j - nums[i]] + nums[i]);
            }
        }
        return dp[target] == target;
    }
}
```

复杂度分析：

- 时间复杂度：O（n^2）
- 空间复杂度：O（n）
